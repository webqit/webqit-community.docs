
	<template name="api">
		<template name="closure">
			<div exportgroup="readme">

				<h1 id="observerclosure"><code>Observer.closure()</code></h1>
<p>This function provides a <em>observer-aware</em> context under which to execute code that could potentially mutate an observed object. Under this context, all mutations made to the object will be detected and <a href="../api/observe.md"><em>observers</em></a> that may be bound to the object will be notified.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#related-methods">Related Methods</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Establish a closure on one or more objects</span>
Observer.closure(callback, object1[, object2[, …]]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>callback:    Function</code> - the closure's callback function. This function recieves the listed objects into the closure in the order they were listed.</li>
<li><code>object1:     Object|Array</code> - an object or array to observe.</li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>undefined</em></p>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The observed object/array</span>
<span class="hljs-keyword">let</span> arr = [], obj = {};
Observer.observe(arr, changes =&gt; {
    <span class="hljs-built_in">console</span>.log(changes);
});

<span class="hljs-comment">// The closure</span>
Observer.closure(<span class="hljs-function">(<span class="hljs-params">arr, obj</span>) =&gt;</span> {
    arr.push(<span class="hljs-string">'one'</span>);
    arr.push(<span class="hljs-string">'two'</span>);
    arr.push(<span class="hljs-string">'three'</span>);
    arr.push(<span class="hljs-string">'four'</span>);
    arr.shift();
}, arr, obj);</code></pre>
<p>The above operation above will notify our observer <em>once</em> for a <em>set</em> operation on the properties <code>0</code>, <code>1</code>, <code>2</code>, <code>length</code>.</p>
<p>Notice that changes are detected and <a href="../api/observe.md"><em>observers</em></a> fired after the code runs. These changes are detected by comparing the state of the object before and after the transaction. Intermediate changes, therefore, do not get caught, and <a href="../api/interceptors.md"><em>interceptors</em></a> that may have been bound to the object don't get fired. (Compare <a href="../api/proxy.md"><code>Observer.proxy()</code></a>.)</p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="../api/proxy.md"><code>Observer.proxy()</code></a></li>
<li><a href="../api/observe.md"><code>Observer.observe()</code></a></li>
<li><a href="../api/intercept.md"><code>Observer.intercept()</code></a></li>
</ul>

			</div>
		</template>

		<template name="defineproperty">
			<div exportgroup="readme">

				<h1 id="observerdefineproperty"><code>Observer.defineProperty()</code></h1>
<p>This method is used to define a property on an object or modifies an existing property. It corresponds to the JavaScript's <code>Reflect.defineProperty()</code> function.</p>
<p><code>Observer.defineProperty()</code> brings the added benefit of driving <a href="../api/observe.md"><em>observers</em></a> and <a href="../api/intercept.md"><em>interceptors</em></a>.</p>
<p>The <code>Observer.def()</code> function is an alias of this function and can be used interchangeably.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#usage-as-a-traps-defineproperty-handler">Usage as a Trap's defineProperty Handler</a></li>
<li><a href="#Intercepting-observer.defineproperty">Intercepting <code>Observer.defineProperty()</code></a></li>
<li><a href="#related-methods">Related Methods</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Define a property</span>
Observer.defineProperty(obj, propertyName, propertyDescriptor);

<span class="hljs-comment">// Define a list of properties</span>
Observer.defineProperty(obj, propertyNames, propertyDescriptor);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:                 Object|Array</code> - an object or array.</li>
<li><code>propertyName:        String</code> - the property to define.</li>
<li><code>propertyNames:       Array</code> - a list of properties to define with the same <em>propertyDescriptor</em>.</li>
<li><code>propertyDescriptor:  Object</code> - the property descriptor as specified for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect"><code>Reflect.defineProperty()</code></a>.</li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>Boolean</em><br />
<em>Object</em> - See <a href="#returning-responses-back-from-observers">Returning Responses Back from Observers</a></p>
<h2 id="usage">Usage</h2>
<h3 id="defining-a-specific-property">Defining a Specific Property</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an object</span>
Observer.defineProperty(obj, <span class="hljs-string">'fruit'</span>, {<span class="hljs-attr">value</span>:<span class="hljs-string">'orange'</span>});</code></pre>
<h3 id="defining-a-list-of-properties">Defining a List of Properties</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an object</span>
Observer.defineProperty(obj, [<span class="hljs-string">'fruit'</span>, <span class="hljs-string">'brand'</span>], {<span class="hljs-attr">value</span>:<span class="hljs-string">'orange'</span>});</code></pre>
<h3 id="passing-a-value-to-observers">Passing a Value to Observers</h3>
<p>The <code>params.detail</code> property can be used to pass a value specifically to observers that might be responding to the <code>del</code> event. Any type of value can be passed.</p>
<pre><code class="hljs js language-js">Observer.defineProperty(obj, propertyName, propertyDescriptor, {
    <span class="hljs-attr">detail</span>: <span class="hljs-string">'This is observer-specific detail'</span>,
});</code></pre>
<p>The <em>detail</em> above would now be available to every handler.</p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, event =&gt; {
    <span class="hljs-built_in">console</span>.log(event.detail);
});</code></pre>
<h3 id="returning-responses-back-from-observers">Returning Responses Back from Observers</h3>
<p>When a <em>def</em> operation fires an event, event handlers recieve a special object, called the <em>Response Object</em>, in addition to the standard event object. The Response Object can be used to, either <em>halt</em>, or <em>keep in sync</em> with what happens next.</p>
<p><strong>response.stopPropagation()</strong> cancels the event, that is, prevents the event from reaching other event handlers. Returning <code>false</code> from the handler has the same effect. </p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, (event, response) =&gt; {
    response.stopPropagation();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the <em>def</em> operation has to flag the event as <em>cancellable</em> for the above to be honoured. It may also obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = Observer.defineProperty(obj, propertyName, propertyDescriptor, {
    <span class="hljs-attr">cancellable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">responseObject</span>: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.propagationStopped) {
}</code></pre>
<p><strong>response.preventDefault()</strong> tells the initiator of the <em>def</em> operation to skip the usual default action it takes after <em>def</em> operations. Returning <code>false</code> from the handler has the same effect. (The event still reaches other handlers.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, (event, response) =&gt; {
    response.preventDefault();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the <em>def</em> operation may obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = Observer.defineProperty(obj, propertyName, propertyDescriptor, {
    <span class="hljs-attr">responseObject</span>: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.defaultPrevented) {
}</code></pre>
<p><strong>response.waitUntil(promise)</strong> tells the initiator of the <em>def</em> operation to wait until a <em>Promise</em> is resolved before continuing with further operations. Returning a <code>Promise</code> from the handler has the same effect. (The event still reaches other handlers without waiting.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, (event, response) =&gt; {
    <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(resolve, <span class="hljs-number">2000</span>);
    });
    response.waitUntil(promise);
    <span class="hljs-comment">// Or, return promise;</span>
});</code></pre>
<p>The initiator of the <em>def</em> operation may obtain the response object to determine the state of this response. The state of this response becomes a promise when one or more handlers return a promise.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = Observer.defineProperty(obj, propertyName, propertyDescriptor, {
    <span class="hljs-attr">responseObject</span>: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.promises) {
    response.promises.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    });
}</code></pre>
<h2 id="usage-as-a-traps-defineproperty-handler">Usage as a Trap's defineProperty Handler</h2>
<p><code>Observer.defineProperty()</code> returns a <em>Boolean</em> value by default, and can, therefore, be used as the "defineProperty" handler in Proxy traps.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, {<span class="hljs-attr">defineProperty</span>: Observer.defineProperty});
<span class="hljs-keyword">let</span> _arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(arr, {<span class="hljs-attr">defineProperty</span>: Observer.defineProperty});</code></pre>
<p><em>Define</em> operations will now be forwarded to <code>Observer.defineProperty()</code> and <a href="../api/observe.md"><em>observers</em></a> and <a href="../api/intercept.md"><em>interceptors</em></a> that may be bound to the object will continue to respond.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">Reflect</span>.defineProperty(_obj, <span class="hljs-string">'fruit'</span>, {<span class="hljs-attr">value</span>:<span class="hljs-string">'apple'</span>});</code></pre>
<h2 id="intercepting-observerdefineproperty">Intercepting <code>Observer.defineProperty()</code></h2>
<p>Using <a href="../api/intercept.md"><code>Observer.intercept()</code></a>, it is possible to intercept calls to <code>Observer.defineProperty()</code>. When a "def" operation triggers an interceptor, the interceptor will receive an event object containing the property name to define and the property descriptor.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">'def'</span>, (event, recieved, next) =&gt; {
    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name, event.descriptor);
    <span class="hljs-comment">// The define operation, and the return value - Boolean</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.defineProperty(obj, event.name, event.descriptor);
});

Observer.defineProperty(obj, <span class="hljs-string">'fruit'</span>, {<span class="hljs-attr">value</span>:<span class="hljs-string">'apple'</span>});</code></pre>
<p>The interceptor is expected to return <em>true</em> when the deletion is successful; <em>false</em> otherwise.</p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="../api/observe.md"><code>Observer.observe()</code></a></li>
<li><a href="../api/intercept.md"><code>Observer.intercept()</code></a></li>
</ul>

			</div>
		</template>

		<template name="deleteproperty">
			<div exportgroup="readme">

				<h1 id="observerdeleteproperty"><code>Observer.deleteProperty()</code></h1>
<p>This method is used to delete an object's property. It corresponds to the JavaScript's <code>Reflect.deleteProperty()</code> function, which is itself the programmatic alternative to the assignment expression – <code>delete obj.property</code>.</p>
<p><code>Observer.deleteProperty()</code> brings the added benefit of triggering <a href="../api/observe.md"><em>observers</em></a> and <a href="../api/intercept.md"><em>interceptors</em></a>.</p>
<p>The <code>Observer.del()</code> function is an alias of this function and can be used interchangeably.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#usage-as-a-traps-deleteproperty-handler">Usage as a Trap's "deleteProperty" Handler</a></li>
<li><a href="#Intercepting-observer.deleteproperty">Intercepting <code>Observer.deleteProperty()</code></a></li>
<li><a href="#related-methods">Related Methods</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Delete a specific property</span>
Observer.deleteProperty(obj, propertyName);

<span class="hljs-comment">// Delete a list of properties</span>
Observer.deleteProperty(obj, propertyNames);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:             Object|Array</code> - an object or array.</li>
<li><code>propertyName:    String</code> - the property to delete.</li>
<li><code>propertyNames:   Array</code> - a list of properties to delete.</li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>Boolean</em><br />
<em>Object</em> - See <a href="#returning-responses-back-from-observers">Returning Responses Back from Observers</a></p>
<h2 id="usage">Usage</h2>
<h3 id="deleting-a-specific-property">Deleting a Specific Property</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an object</span>
Observer.deleteProperty(obj, <span class="hljs-string">'fruit'</span>);
<span class="hljs-comment">// On an array</span>
Observer.deleteProperty(arr, <span class="hljs-number">0</span>);</code></pre>
<h3 id="deleting-a-list-of-properties">Deleting a List of Properties</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an object</span>
Observer.deleteProperty(obj, [<span class="hljs-string">'fruit'</span>, <span class="hljs-string">'brand'</span>]);
<span class="hljs-comment">// On an array</span>
Observer.deleteProperty(arr, [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>]);</code></pre>
<h3 id="passing-a-value-to-observers">Passing a Value to Observers</h3>
<p>The <code>params.detail</code> property can be used to pass a value specifically to observers that might be responding to the <code>del</code> event. Any type of value can be passed.</p>
<pre><code class="hljs js language-js">Observer.deleteProperty(obj, propertyName, {
    <span class="hljs-attr">detail</span>: <span class="hljs-string">'This is observer-specific detail'</span>,
});</code></pre>
<p>The <em>detail</em> above would now be available to every handler.</p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, event =&gt; {
    <span class="hljs-built_in">console</span>.log(event.detail);
});</code></pre>
<h3 id="returning-responses-back-from-observers">Returning Responses Back from Observers</h3>
<p>When a <em>del</em> operation fires an event, event handlers recieve a special object, called the <em>Response Object</em>, in addition to the standard event object. The Response Object can be used to, either <em>halt</em>, or <em>keep in sync</em> with what happens next.</p>
<p><strong>response.stopPropagation()</strong> cancels the event, that is, prevents the event from reaching other event handlers. Returning <code>false</code> from the handler has the same effect. </p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, (event, response) =&gt; {
    response.stopPropagation();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the <em>del</em> operation has to flag the event as <em>cancellable</em> for the above to be honoured. It may also obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = Observer.deleteProperty(obj, propertyName, {
    <span class="hljs-attr">cancellable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">responseObject</span>: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.propagationStopped) {
}</code></pre>
<p><strong>response.preventDefault()</strong> tells the initiator of the <em>del</em> operation to skip the usual default action it takes after <em>del</em> operations. Returning <code>false</code> from the handler has the same effect. (The event still reaches other handlers.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, (event, response) =&gt; {
    response.preventDefault();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the <em>del</em> operation may obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = Observer.deleteProperty(obj, propertyName, {
    <span class="hljs-attr">responseObject</span>: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.defaultPrevented) {
}</code></pre>
<p><strong>response.waitUntil(promise)</strong> tells the initiator of the <em>del</em> operation to wait until a <em>Promise</em> is resolved before continuing with further operations. Returning a <code>Promise</code> from the handler has the same effect. (The event still reaches other handlers without waiting.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, (event, response) =&gt; {
    <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(resolve, <span class="hljs-number">2000</span>);
    });
    response.waitUntil(promise);
    <span class="hljs-comment">// Or, return promise;</span>
});</code></pre>
<p>The initiator of the <em>del</em> operation may obtain the response object to determine the state of this response. The state of this response becomes a promise when one or more handlers return a promise.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = Observer.deleteProperty(obj, propertyName, {
    <span class="hljs-attr">responseObject</span>: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.promises) {
    response.promises.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    });
}</code></pre>
<h2 id="usage-as-a-traps-deleteproperty-handler">Usage as a Trap's "deleteProperty" Handler</h2>
<p><code>Observer.deleteProperty()</code> returns a <em>Boolean</em> value by default, and can, therefore, be used as the "deleteProperty" handler in Proxy traps.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, {<span class="hljs-attr">deleteProperty</span>: Observer.deleteProperty});
<span class="hljs-keyword">let</span> _arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(arr, {<span class="hljs-attr">deleteProperty</span>: Observer.deleteProperty});</code></pre>
<p>Delete operations will now be forwarded to <code>Observer.deleteProperty()</code> and <a href="../api/observe.md"><em>observers</em></a> and <a href="../api/intercept.md"><em>interceptors</em></a> that may be bound to the object will continue to respond.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">delete</span> _obj.fruit;
<span class="hljs-keyword">delete</span> _arr[<span class="hljs-number">2</span>];</code></pre>
<h2 id="intercepting-observerdeleteproperty">Intercepting <code>Observer.deleteProperty()</code></h2>
<p>Using <a href="../api/intercept.md"><code>Observer.intercept()</code></a>, it is possible to intercept calls to <code>Observer.deleteProperty()</code>. When a "del" operation triggers an interceptor, the interceptor will receive an event object containing the property name to delete.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">'del'</span>, (event, recieved, next) =&gt; {
    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name);
    <span class="hljs-comment">// The delete operation</span>
    <span class="hljs-keyword">delete</span> obj[event.name];
    <span class="hljs-comment">// The return value - Boolean</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
});

Observer.deleteProperty(obj, <span class="hljs-string">'fruit'</span>);</code></pre>
<p>When the "del" operation is of multiple deletion, the interceptor gets fired for each pair while also recieving the total list of properties as a hint - via <code>event.related</code>.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">'del'</span>, (event, recieved, next) =&gt; {
    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name, event.related);
    <span class="hljs-comment">// The delete operation</span>
    <span class="hljs-keyword">delete</span> obj[event.name];
    <span class="hljs-comment">// The return value - Boolean</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
});

Observer.deleteProperty(obj, [<span class="hljs-string">'orange'</span>, <span class="hljs-string">'apple'</span>]);</code></pre>
<p>The above should trigger our interceptor twice with <code>event.related</code> being <code>['fruit', 'brand']</code>.</p>
<p>The interceptor is expected to return <em>true</em> when the deletion is successful; <em>false</em> otherwise.</p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="../api/observe.md"><code>Observer.observe()</code></a></li>
<li><a href="../api/intercept.md"><code>Observer.intercept()</code></a></li>
</ul>

			</div>
		</template>

		<template name="get">
			<div exportgroup="readme">

				<h1 id="observerget"><code>Observer.get()</code></h1>
<p>This method is used to read a property. It corresponds to the JavaScript's <code>Reflect.get()</code> function, which is itself the programmatic alternative to the syntax for property access – <code>obj.property; obj[property]</code>.</p>
<p><code>Observer.get()</code> brings the added benefit of triggering <a href="../api/intercept.md"><em>interceptors</em></a>.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#usage-as-a-traps-get-handler">Usage as a Trap's "get" Handler</a></li>
<li><a href="#usage-with-property-getters">Usage with Property Getters</a></li>
<li><a href="#Intercepting-observer.get">Intercepting <code>Observer.get()</code></a></li>
<li><a href="#related-methods">Related Methods</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Read a specific property.</span>
<span class="hljs-comment">// The return value will be the value of the property</span>
<span class="hljs-keyword">var</span> value = Observer.get(object, propertyName);

<span class="hljs-comment">// Read a list of properties</span>
<span class="hljs-comment">// The return value will be a key/value map of the listed properties</span>
<span class="hljs-keyword">var</span> values = Observer.get(object, propertyNames);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:             Object|Array</code> - an object or array.</li>
<li><code>propertyName:    String</code> - the property to read.</li>
<li><code>propertyNames:   Array</code> - a list of properties to read.</li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><code>value:   Any</code> - the value of the property</li>
<li><code>values:  Object</code> - a key/value map of the listed properties</li>
</ul>
<h2 id="usage">Usage</h2>
<h3 id="reading-a-specific-property">Reading a Specific Property</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">fruit</span>:<span class="hljs-string">'orange'</span>,
    <span class="hljs-attr">brand</span>:<span class="hljs-string">'apple'</span>,
};

<span class="hljs-keyword">let</span> fruit = Observer.get(obj, <span class="hljs-string">'fruit'</span>);</code></pre>
<h3 id="reading-a-list-of-properties">Reading a List of Properties</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">fruit</span>:<span class="hljs-string">'orange'</span>,
    <span class="hljs-attr">brand</span>:<span class="hljs-string">'apple'</span>,
};

<span class="hljs-keyword">let</span> fruits = Observer.get(obj, [<span class="hljs-string">'fruit'</span>, <span class="hljs-string">'brand'</span>]);</code></pre>
<h2 id="usage-as-a-traps-get-handler">Usage as a Trap's "get" Handler</h2>
<p><code>Observer.get()</code> can be used as the "get" handler in Proxy traps.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, {<span class="hljs-attr">get</span>: Observer.get});
<span class="hljs-keyword">let</span> _arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(arr, {<span class="hljs-attr">get</span>: Observer.get});</code></pre>
<p><em>Read</em> operations will now be forwarded to <code>Observer.get()</code> and <a href="../api/intercept.md"><em>interceptors</em></a> that may be bound to the object will continue to respond.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> fruit = _obj.fruit;
<span class="hljs-keyword">let</span> value = _arr[<span class="hljs-number">2</span>];</code></pre>
<h2 id="usage-with-property-getters">Usage with Property Getters</h2>
<p>It is possible to implement <em>property getters</em> that use <code>Observer.get()</code> behind the scene. This gives us the benefit of using JavaScript's property access syntax while still driving <a href="../api/intercept.md"><em>interceptors</em></a>.</p>
<p>This is automatically done by the <a href="../api/init.md"><code>Observer.init()</code></a> support function.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Virtualize a property or multiple properties</span>
Observer.init(obj, <span class="hljs-string">'fruit'</span>);
Observer.init(obj, [<span class="hljs-string">'fruit'</span>, <span class="hljs-string">'brand'</span>]);

<span class="hljs-comment">// Now we can do without Observer.get</span>
<span class="hljs-keyword">let</span> fruit = obj.fruit;
<span class="hljs-keyword">let</span> brand = obj.brand;</code></pre>
<p>We could follow the pattern above for arrays; we could even <em>init</em> an array's prototype methods instead. The specific keys modified after calling these methods will be announced to <a href="../api/observe.md"><em>observers</em></a>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Virtualize the arr.push() and arr.splice() methods</span>
Observer.init(arr, [<span class="hljs-string">'push'</span>, <span class="hljs-string">'splice'</span>]);

<span class="hljs-comment">// Now we can do without Observer.set</span>
arr.push(<span class="hljs-string">'Item 1'</span>);
arr.push(<span class="hljs-string">'Item 2'</span>);
arr.splice(<span class="hljs-number">1</span>);</code></pre>
<h2 id="intercepting-observerget">Intercepting <code>Observer.get()</code></h2>
<p>Using <a href="../api/intercept.md"><code>Observer.intercept()</code></a>, it is possible to intercept calls to <code>Observer.get()</code>. When a "get" operation triggers an interceptor, the interceptor will receive an event object containing the property name to read.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">'get'</span>, (event, recieved, next) =&gt; {
    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name);
    <span class="hljs-comment">// The read operation</span>
    <span class="hljs-keyword">return</span> obj[event.name];
});

<span class="hljs-keyword">let</span> value = Observer.get(obj, <span class="hljs-string">'fruit'</span>);</code></pre>
<p>When the "get" operation is of multiple properties, the interceptor gets fired for each property while also recieving the total list of properties as a hint - via <code>event.related</code>.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">'get'</span>, (event, recieved, next) =&gt; {
    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name, event.related);
    <span class="hljs-comment">// The read operation</span>
    <span class="hljs-keyword">return</span> obj[event.name];
});

<span class="hljs-keyword">let</span> values = Observer.get(obj, [<span class="hljs-string">'orange'</span>, <span class="hljs-string">'apple'</span>]);</code></pre>
<p>The above should trigger our interceptor twice with <code>event.related</code> being <code>['fruit', 'brand']</code>.</p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="../api/observe.md"><code>Observer.observe()</code></a></li>
<li><a href="../api/intercept.md"><code>Observer.intercept()</code></a></li>
</ul>

			</div>
		</template>

		<template name="has">
			<div exportgroup="readme">

				<h1 id="observerhas"><code>Observer.has()</code></h1>
<p>This method is used to test property presence. It corresponds to the JavaScript's built-in <code>Reflect.has()</code> function, which is itself the programmatic alternative to the JavaScript <em>in</em> operator – <code>property in obj</code>.</p>
<p><code>Observer.has()</code> brings the added benefit of triggering <a href="../api/intercept.md"><em>interceptors</em></a>.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#usage-as-a-traps-has-handler">Usage as a Trap's "has" Handler</a></li>
<li><a href="#Intercepting-observer.has">Intercepting <code>Observer.has()</code></a></li>
<li><a href="#related-methods">Related Methods</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Test the presence of a property.</span>
<span class="hljs-keyword">let</span> exists = Observer.has(obj, propertyName);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:             Object|Array</code> - an object or array.</li>
<li><code>propertyName:    String</code> - the property to test.</li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>Boolean</em></p>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">fruit</span>:<span class="hljs-string">'orange'</span>,
    <span class="hljs-attr">brand</span>:<span class="hljs-string">'apple'</span>,
};

<span class="hljs-keyword">let</span> exists = Observer.has(obj, <span class="hljs-string">'fruit'</span>);</code></pre>
<h2 id="usage-as-a-traps-has-handler">Usage as a Trap's "has" Handler</h2>
<p><code>Observer.has()</code> can be used as the "has" handler in Proxy traps.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, {<span class="hljs-attr">has</span>: Observer.has});
<span class="hljs-keyword">let</span> _arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(arr, {<span class="hljs-attr">has</span>: Observer.has});</code></pre>
<p><em>Exists</em> operations will now be forwarded to <code>Observer.has()</code> and <a href="../api/intercept.md"><em>interceptors</em></a> that may be bound to the object will continue to respond.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> exists = <span class="hljs-string">'fruit'</span> <span class="hljs-keyword">in</span> _obj;
<span class="hljs-keyword">let</span> exists = <span class="hljs-string">'1'</span> <span class="hljs-keyword">in</span> _arr;</code></pre>
<h2 id="intercepting-observerhas">Intercepting <code>Observer.has()</code></h2>
<p>Using <a href="../api/intercept.md"><code>Observer.intercept()</code></a>, it is possible to intercept calls to <code>Observer.has()</code>. When a "has" operation triggers an interceptor, the interceptor will receive an event object containing the property name to check.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">'has'</span>, (event, recieved, next) =&gt; {
    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name);
    <span class="hljs-comment">// The read operation</span>
    <span class="hljs-keyword">return</span> event.name <span class="hljs-keyword">in</span> obj;
});

<span class="hljs-keyword">let</span> exists = Observer.has(obj, <span class="hljs-string">'fruit'</span>);</code></pre>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="../api/observe.md"><code>Observer.observe()</code></a></li>
<li><a href="../api/intercept.md"><code>Observer.intercept()</code></a></li>
</ul>

			</div>
		</template>

		<template name="init">
			<div exportgroup="readme">

				<h1 id="observerinit"><code>Observer.init()</code></h1>
<p>This function is used to implement property <em>setters</em> and <em>getters</em> that use <code>Observer.set()</code> and <code>Observer.get()</code> respectively behind the scene. This gives us the benefit of using JavaScript's assignment and accessor syntax while still driving <a href="../api/observe.md"><em>observers</em></a> and <a href="../api/intercept.md"><em>interceptors</em></a>.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Init a single property</span>
Observer.init(object, propertyName);

<span class="hljs-comment">// Init multiple properties</span>
Observer.init(object, propertyNames);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:             Object|Array</code> - an object or array.</li>
<li><code>propertyName:    String</code> - the property to <em>initialize</em>.</li>
<li><code>propertyNames:   Array</code> - a list of properties to <em>initialize</em>.</li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>undefined</em></p>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The object</span>
<span class="hljs-keyword">let</span> obj = {};

<span class="hljs-comment">// We observe the 'preferences' property</span>
Observer.observe(obj, <span class="hljs-string">'preferences'</span>, changes =&gt; {
    <span class="hljs-built_in">console</span>.log(changes);
});

<span class="hljs-comment">// Now we virtualize this property</span>
Observer.init(obj, <span class="hljs-string">'preferences'</span>);

<span class="hljs-comment">// We use the property and watch our console.</span>
obj.preferences = {};</code></pre>

			</div>
		</template>

		<template name="intercept">
			<div exportgroup="readme">

				<h1 id="observerintercept"><code>Observer.intercept()</code></h1>
<p>This method is used to intercept operations performed on an object or array with custom handlers. Requests like <em>set</em>, <em>delete</em>, <em>get</em> and <em>has</em> are trapped and forwarded to these custom handlers.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#tagging-an-interceptor">Tagging an Interceptor</a></li>
<li><a href="#setting-multiple-interceptors">Setting Multiple Interceptors</a></li>
<li><a href="#the-returned-interceptor-instance">The Returned Interceptor Instance</a></li>
<li><a href="#related-methods">Related Methods</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Intercept all operations or queries</span>
Observer.intercept(obj, handler[, params = {}]);

<span class="hljs-comment">// Intercept a specific operation</span>
Observer.intercept(obj, type, handler[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:     Object|Array</code> - an object or array.</li>
<li><code>type:    String</code> - the operation to intercept.</li>
<li><code>handler: Function</code> - a function that handles the operation. This recieves:<ul>
<li><code>event:       Event</code> - an object containing details of the operation.</li>
<li><code>recieved:    Any</code> - the return value of a previous trap in the list, if any.</li>
<li><code>next:        Function</code> - a function that calls the next trap in the list, if any.</li></ul></li>
<li><code>params:  Object</code> - Additional parameters.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>An <a href="#the-returned-interceptor-instance"><em>Interceptor</em> instance</a>.</p>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {<span class="hljs-attr">name</span>: <span class="hljs-string">'reflex'</span>,};
<span class="hljs-keyword">let</span> getVersionNumberRemotely = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'1.0.0'</span>;</code></pre>
<p>Below, we're intercepting the "get" request and skipping all other requests using the <code>next()</code> function we receive in our handler. This trap will "lazy-load" the object's version value.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, (event, recieved, next) =&gt; {
    <span class="hljs-keyword">if</span> (event.type === <span class="hljs-string">'get'</span>) {
        <span class="hljs-keyword">let</span> requestedKey = event.name;
        <span class="hljs-keyword">if</span> (requestedKey === <span class="hljs-string">'version'</span> &amp;&amp; !(requestedKey <span class="hljs-keyword">in</span> obj)) {
            obj[requestedKey]; =  getVersionNumberRemotely();
        }
        <span class="hljs-keyword">return</span> obj[requestedKey];
    }
    <span class="hljs-keyword">return</span> next();
});</code></pre>
<p>Now, let's see what we get for each property we access.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">console</span>.log(Observer.get(obj, <span class="hljs-string">'name'</span>)); <span class="hljs-comment">// 'reflex'</span>
<span class="hljs-built_in">console</span>.log(Observer.get(obj, <span class="hljs-string">'version'</span>)); <span class="hljs-comment">// '1.0.0'</span></code></pre>
<p>In another case, we're intercepting a "set" operation to validate the incoming value for a specific property. We're using the <code>type</code> parameter to constrain the trap to just the "set" type.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">'set'</span>, (event, recieved, next) =&gt; {
    <span class="hljs-keyword">let</span> requestedKey = event.name;
    <span class="hljs-keyword">let</span> requestedValue = event.value;
    <span class="hljs-keyword">if</span> (requestedKey === <span class="hljs-string">'url'</span> &amp;&amp; !requestedValue.startsWith(<span class="hljs-string">'http'</span>)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'The url property only accepts a valid URL!'</span>);
    }
    obj[requestedKey] = requestedValue;
    <span class="hljs-comment">// We return true here</span>
    <span class="hljs-comment">// and it's always good to still call next() with a return a value</span>
    <span class="hljs-keyword">return</span> next(<span class="hljs-literal">true</span>);
});</code></pre>
<p>Now, let's attempt setting different URLs on our object. Remember that <code>Observer.set()</code> will also trigger observers that may be bound to the object.</p>
<pre><code class="hljs js language-js"><span class="hljs-built_in">console</span>.log(Observer.set(obj, <span class="hljs-string">'url'</span>, <span class="hljs-string">'https://example.com'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(Observer.set(obj, <span class="hljs-string">'url'</span>, <span class="hljs-string">'example.com'</span>)); <span class="hljs-comment">// Fatal Error</span></code></pre>
<h2 id="tagging-an-interceptor">Tagging an Interceptor</h2>
<p>The <code>params.tags</code> parameter can be used to tag a trap. Tags are an <em>array</em> of values (<em>strings</em>, <em>numbers</em>, <em>objects</em>, etc) that can be used to identify the trap for later use.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, handler, {<span class="hljs-attr">tags</span>:[<span class="hljs-string">'#tag'</span>]});</code></pre>
<h2 id="setting-multiple-interceptors">Setting Multiple Interceptors</h2>
<p>Multiple traps can rightly be set on an object. Each trap called will have the decision to call the next. A trap is called with the return value of the previous trap (or <em>undefined</em> where there is no previous trap) and a reference to the next trap (or a reference to the default handler where there is no next trap).</p>
<p>Below, we set an additional trap to handle setting the url property. But this time, we wouldn't bother if the previous trap has handled this.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">'set'</span>, (event, recieved, next) =&gt; {
    If (received === <span class="hljs-literal">true</span>) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A previous handler has handled this!'</span>);
        <span class="hljs-keyword">return</span> next(<span class="hljs-literal">true</span>);
    }
    <span class="hljs-comment">// We could do the work here</span>
    <span class="hljs-comment">// or simply leave it to the default property setter</span>
    <span class="hljs-keyword">return</span> next();
});</code></pre>
<h2 id="the-returned-interceptor-instance">The Returned Interceptor Instance</h2>
<p>The <code>Observer.intercept()</code> method returns an <em>Interceptor</em> instance that gives us per-instance control.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain the Interceptor instance</span>
<span class="hljs-keyword">let</span> instance = Observer.intercept(obj, handler);

<span class="hljs-comment">// Synthetically fire the handler</span>
instance.fire({
    <span class="hljs-attr">type</span>:<span class="hljs-string">'set'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'propertyName'</span>
    <span class="hljs-attr">value</span>:<span class="hljs-string">'...'</span>,
});

<span class="hljs-comment">// Disconnect the trap</span>
instance.disconnect();</code></pre>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="../api/unintercept.md"><code>Observer.unintercept()</code></a></li>
<li><a href="../api/set.md"><code>Observer.set()</code></a></li>
<li><a href="../api/get.md"><code>Observer.get()</code></a></li>
<li><a href="../api/has.md"><code>Observer.has()</code></a></li>
<li><a href="../api/deleteproperty.md"><code>Observer.deleteProperty()</code></a></li>
<li><a href="../api/deleteproperty.md"><code>Observer.del()</code></a></li>
<li><a href="../api/defineproperty.md"><code>Observer.defineProperty()</code></a></li>
<li><a href="../api/defineproperty.md"><code>Observer.def()</code></a></li>
<li><a href="../api/keys.md"><code>Observer.keys()</code></a></li>
<li><a href="../api/ownkeys.md"><code>Observer.ownKeys()</code></a></li>
</ul>

			</div>
		</template>

		<template name="observe">
			<div exportgroup="readme">

				<h1 id="observerobserve"><code>Observer.observe()</code></h1>
<p>This method is used to observe changes to an object or array.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#specifying-an-event-type">Specifying an Event Type</a></li>
<li><a href="#tagging-an-observer">Tagging an Observer</a></li>
<li><a href="#the-returned-observer-instance">The Returned Observer Instance</a></li>
<li><a href="#related-methods">Related Methods</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Observe all properties</span>
Observer.observe(obj, callback[, params = {}]);

<span class="hljs-comment">// Observe a specific path</span>
Observer.observe(obj, path, callback[, params = {}]);

<span class="hljs-comment">// Observe a list of paths</span>
Observer.observe(obj, paths, callback[, params = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:         Object|Array</code> - an object or array.</li>
<li><code>path:        String|Array</code> - a path to observe.</li>
<li><code>paths:       Array</code> - the list of paths to observe.</li>
<li><code>callback:    Function</code> - a callback function that receives the change notifications. This recieves:<ul>
<li><code>changes/change</code> - an <em>event</em> or a list of <em>events</em> (in the case of the last syntax above.)</li></ul></li>
<li><code>params:      Object</code> - Additional parameters.</li>
</ul>
<p><strong>Return Value</strong></p>
<p>An <a href="#the-returned-observer-instance"><em>Observer</em> instance</a>.</p>
<h2 id="usage">Usage</h2>
<ul>
<li><a href="#observing-all-properties">Observing All Properties</a></li>
<li><a href="#observing-a-path">Observing a Path</a></li>
<li><a href="#observing-a-list-of-paths">Observing a List of Paths</a></li>
</ul>
<h3 id="observing-all-properties">Observing All Properties</h3>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> callback = <span class="hljs-function"><span class="hljs-params">events</span> =&gt;</span> {
    events.forEach(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(event.type, event.name, event.path, event.value, event.oldValue);
    });
};
<span class="hljs-keyword">let</span> obj = {};
Observer.observe(obj, callback);</code></pre>
<p>The code above will report changes as the <em>object</em> gets modified on any of its properties.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> arr = [];
Observer.observe(arr, callback);</code></pre>
<p>The code above will report changes as the <em>array</em> gets modified with entries.</p>
<pre><code class="hljs js language-js">Observer.set(obj, <span class="hljs-string">'fruit'</span>, <span class="hljs-string">'apple'</span>);</code></pre>
<p>With the <em>set</em> operation above, the value of <code>event.name</code> and <code>event.path</code> in the console will be <code>fruit</code> and <code>[fruit]</code> respectively.</p>
<h4 id="using-the-paramssutree-parameter">Using the <code>params.sutree</code> Parameter</h4>
<p>To observe changes on nested objects or arrays, we would use <em>the <code>params.sutree</code> parameter</em>.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">preferences</span>: {},
};
Observer.observe(obj, events =&gt; {
    events.forEach(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(event.type, event.name, event.path, event.value, event.oldValue);
    });
}, {<span class="hljs-attr">subtree</span>:<span class="hljs-literal">true</span>});</code></pre>
<p>The code above will report changes happening down the object tree.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences, <span class="hljs-string">'fruit'</span>, <span class="hljs-string">'apple'</span>);</code></pre>
<p>With the <em>set</em> operation at level 2 above, the value of <code>event.name</code> and <code>event.path</code> in the console will be <code>preferences</code> and <code>['preferences', 'fruit']</code> respectively.</p>
<h3 id="observing-a-path">Observing a Path</h3>
<p>It is possible to observe a specific path on an object or array.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> callback = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.type, event.name, event.path, event.value, event.oldValue);
};

<span class="hljs-keyword">let</span> obj = {};
Observer.observe(obj, <span class="hljs-string">'fruit'</span>, callback);</code></pre>
<p>The code above will report changes as the "fruit" property gets created, modified or deleted on the object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> arr = [];
Observer.observe(arr, <span class="hljs-number">0</span>, callback);</code></pre>
<p>The code above will report changes as the array's first entry gets created, modified or deleted.</p>
<pre><code class="hljs js language-js">Observer.set(obj, <span class="hljs-string">'fruit'</span>, <span class="hljs-string">'apple'</span>);</code></pre>
<p>With the <em>set</em> operation above, the value of <code>event.name</code> and <code>event.path</code> in the console will be <code>fruit</code> and <code>['fruit']</code> respectively.</p>
<h4 id="using-array-path-expressions">Using Array Path Expressions</h4>
<p>Array path expressions are used to observe changes on nested objects or arrays.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">preferences</span>: {},
};
Observer.observe(obj, [<span class="hljs-string">'preferences'</span>, <span class="hljs-string">'fruit'</span>], event =&gt; {
    <span class="hljs-built_in">console</span>.log(event.type, event.name, event.path, event.value, event.oldValue);
});</code></pre>
<p>The code above will report changes that occur at any level along the specified path - <code>['preferences', 'fruit']</code>.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences, <span class="hljs-string">'fruit'</span>, <span class="hljs-string">'orange'</span>);</code></pre>
<p>With the <em>set</em> operation at level 2 above, the value of <code>event.name</code> and <code>event.path</code> in the console will be <code>preferences</code> and <code>['preferences', 'fruit']</code> respectively.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences, <span class="hljs-string">'brand'</span>, <span class="hljs-string">'apple'</span>);</code></pre>
<p>With the <em>set</em> operation at level 2 above, the value of <code>event.name</code> and <code>event.path</code> will be <code>preferences</code> and <code>['preferences', 'brand']</code> respectively. This time, the change isn't happening along the path we're observing. And we don't see anything in the console.</p>
<h3 id="observing-a-list-of-paths">Observing a List of Paths</h3>
<p>It is possible to observe multiple paths at once by giving an array of path arrays. The observer is called with the paths along which an event happened.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> callback = <span class="hljs-function"><span class="hljs-params">events</span> =&gt;</span> {
    events.forEach(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(event.type, event.name, event.path, event.value, event.oldValue);
    });
};

<span class="hljs-keyword">let</span> obj = {};
Observer.observe(obj, [ [<span class="hljs-string">'fruit'</span>], [<span class="hljs-string">'brand'</span>] ], callback);</code></pre>
<p>The code above will report changes as any of "fruit" or "brand" properties get created, modified or deleted on the object.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> arr = [];
Observer.observe(arr, [ [<span class="hljs-number">0</span>], [<span class="hljs-number">3</span>] ], callback);</code></pre>
<p>The code above will report changes as the array's first or fourth entry gets created, modified or deleted.</p>
<pre><code class="hljs js language-js">Observer.set(obj, <span class="hljs-string">'fruit'</span>, <span class="hljs-string">'orange'</span>);</code></pre>
<p>If we made multiple changes in one batch, our observer would recieve multiple events in one call.</p>
<pre><code class="hljs js language-js">Observer.set(obj, {
    <span class="hljs-attr">fruit</span>: <span class="hljs-string">'orange'</span>,
    <span class="hljs-attr">brand</span>: <span class="hljs-string">'apple'</span>,
});</code></pre>
<h4 id="using-wildcard-paths">Using Wildcard Paths</h4>
<p>It is possible to observe multiple paths dynamically using one <em>wildcard path</em> expression. Wildcard paths are paths with empty slots, designed to match <em>event paths</em> as they happen.</p>
<p>Notice below that our path is a 3-level path, with the second level being the wildcard.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">preferences</span>: {
        <span class="hljs-attr">favourites</span>: {},
    },
};
Observer.observe(obj, [<span class="hljs-string">'preferences'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'fruit'</span>], events =&gt; {
    events.forEach(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(event.type, event.name, event.path, event.value, event.oldValue);
    });
});</code></pre>
<p>The code above will report changes when an event fires at a path that fulfills our wildcard path. A path like <code>['preferences', 'favourites', 'fruit']</code> would do that.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences.favourites, <span class="hljs-string">'fruit'</span>, <span class="hljs-string">'mango'</span>);</code></pre>
<p>If we fired multiple matching events in one batch, our observer would recieve multiple events in one call.</p>
<pre><code class="hljs js language-js">Observer.set(obj.preferences.favourites, {
    <span class="hljs-attr">fruit</span>: <span class="hljs-string">'orange'</span>,
    <span class="hljs-attr">brand</span>: <span class="hljs-string">'apple'</span>,
});</code></pre>
<h2 id="specifying-an-event-type">Specifying an Event Type</h2>
<p>The <code>params.type</code> parameter can be used to tell an observer to respond to a specific mutation type like "set" and "del".</p>
<pre><code class="hljs js language-js">Observer.observe(obj, path, callback, {<span class="hljs-attr">type</span>:<span class="hljs-string">'del'</span>});</code></pre>
<h2 id="tagging-an-observer">Tagging an Observer</h2>
<p>The <code>params.tags</code> parameter can be used to tag an observer. Tags are an <em>array</em> of values (<em>strings</em>, <em>numbers</em>, <em>objects</em>, etc) that can be used to identify the observer for later use.</p>
<pre><code class="hljs js language-js">Observer.observe(obj, path, callback, {<span class="hljs-attr">tags</span>:[<span class="hljs-string">'#tag'</span>]});</code></pre>
<h2 id="the-returned-observer-instance">The Returned Observer Instance</h2>
<p>The <code>Observer.observe()</code> method returns an <em>Observer</em> instance that gives us per-instance control.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Obtain the Observer instance</span>
<span class="hljs-keyword">let</span> instance = Observer.observe(obj, callback);

<span class="hljs-comment">// Synthetically fire the observer</span>
instance.fire({
    <span class="hljs-attr">type</span>:<span class="hljs-string">'customType'</span>,
});

<span class="hljs-comment">// Disconnect the observer</span>
instance.disconnect();</code></pre>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="../api/unobserve.md"><code>Observer.unobserve()</code></a></li>
<li><a href="../api/set.md"><code>Observer.set()</code></a></li>
<li><a href="../api/deleteproperty.md"><code>Observer.deleteProperty()</code></a></li>
</ul>

			</div>
		</template>

		<template name="ownkeys">
			<div exportgroup="readme">

				<h1 id="observerownkeys"><code>Observer.ownKeys()</code></h1>
<p>This method is used to get an object's list of direct properties. It corresponds to the JavaScript's <code>Reflect.ownKeys()</code> function.</p>
<p><code>Observer.ownKeys()</code> brings the added benefit of triggering <a href="../api/intercept.md"><em>interceptors</em></a>.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#usage-as-a-traps-ownKeys-handler">Usage as a Trap's "ownKeys" Handler</a></li>
<li><a href="#Intercepting-observer.ownKeys">Intercepting <code>Observer.ownKeys()</code></a></li>
<li><a href="#related-methods">Related Methods</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Show all keys.</span>
<span class="hljs-keyword">let</span> keys = Observer.ownKeys(obj);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:             Object|Array</code> - an object or array.</li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>Array</em></p>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">fruit</span>:<span class="hljs-string">'orange'</span>,
    <span class="hljs-attr">brand</span>:<span class="hljs-string">'apple'</span>,
};

<span class="hljs-keyword">let</span> keys = Observer.ownKeys(obj);</code></pre>
<h2 id="usage-as-a-traps-ownkeys-handler">Usage as a Trap's "ownKeys" Handler</h2>
<p><code>Observer.ownKeys()</code> can be used as the "ownKeys" handler in Proxy traps.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, {<span class="hljs-attr">ownKeys</span>: Observer.ownKeys});
<span class="hljs-keyword">let</span> _arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(arr, {<span class="hljs-attr">ownKeys</span>: Observer.ownKeys});</code></pre>
<p><em>Show keys</em> operations will now be forwarded to <code>Observer.ownKeys()</code> and <a href="../api/intercept.md"><em>interceptors</em></a> that may be bound to the object will continue to respond.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Reflect</span>.ownKeys(_obj);
<span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Reflect</span>.ownKeys(_arr);</code></pre>
<h2 id="intercepting-observerownkeys">Intercepting <code>Observer.ownKeys()</code></h2>
<p>Using <a href="../api/intercept.md"><code>Observer.intercept()</code></a>, it is possible to intercept calls to <code>Observer.ownKeys()</code>.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">'keys'</span>, (event, recieved, next) =&gt; {
    <span class="hljs-comment">// The read operation</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.ownKeys(obj);
});

<span class="hljs-keyword">let</span> keys = Observer.ownKeys(obj);</code></pre>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="../api/observe.md"><code>Observer.observe()</code></a></li>
<li><a href="../api/intercept.md"><code>Observer.intercept()</code></a></li>
</ul>

			</div>
		</template>

		<template name="proxy">
			<div exportgroup="readme">

				<h1 id="observerproxy"><code>Observer.proxy()</code></h1>
<p>This function wraps an object or array in a proxy with all operations on the instance forwarded to the appropriate <a href="../api/interceptors.md"><em>interceptors</em></a>, and announced to <a href="../api/observe.md"><em>observers</em></a>.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#related-methods">Related Methods</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Wrap an object</span>
<span class="hljs-keyword">let</span> _obj = Observer.proxy(obj);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:             Object|Array</code> - an object or array.</li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>Proxy</em></p>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// The observed object/array</span>
<span class="hljs-keyword">let</span> arr = [];
Observer.observe(arr, changes =&gt; {
    <span class="hljs-built_in">console</span>.log(changes);
});

<span class="hljs-comment">// The proxy</span>
Observer.proxy(arr).push(<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>);</code></pre>
<p>The above operation above will notify our observer <em>three times</em> each for a <em>set</em> operation on the properties <code>0</code>, <code>1</code>, <code>length</code>.</p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="../api/closure.md"><code>Observer.closure()</code></a></li>
<li><a href="../api/observe.md"><code>Observer.observe()</code></a></li>
<li><a href="../api/intercept.md"><code>Observer.intercept()</code></a></li>
</ul>

			</div>
		</template>

		<div exportgroup="readme">

			<h1 id="api-documentation">API Documentation</h1>
<h2 id="observer">Observer</h2>
<ul>
<li><a href="../api/observe.md"><code>Observer.observe()</code></a></li>
<li><a href="../api/unobserve.md"><code>Observer.unobserve()</code></a></li>
</ul>
<h2 id="interception">Interception</h2>
<ul>
<li><a href="../api/intercept.md"><code>Observer.intercept()</code></a></li>
<li><a href="../api/unintercept.md"><code>Observer.unintercept()</code></a></li>
</ul>
<h2 id="operators">Operators</h2>
<ul>
<li><a href="../api/set.md"><code>Observer.set()</code></a></li>
<li><a href="../api/get.md"><code>Observer.get()</code></a></li>
<li><a href="../api/has.md"><code>Observer.has()</code></a></li>
<li><a href="../api/deleteproperty.md"><code>Observer.deleteProperty()</code></a></li>
<li><a href="../api/deleteproperty.md"><code>Observer.del()</code></a></li>
<li><a href="../api/defineproperty.md"><code>Observer.defineProperty()</code></a></li>
<li><a href="../api/defineproperty.md"><code>Observer.def()</code></a></li>
<li><a href="../api/keys.md"><code>Observer.keys()</code></a></li>
<li><a href="../api/ownkeys.md"><code>Observer.ownKeys()</code></a></li>
</ul>
<h2 id="support-methods">Support Methods</h2>
<ul>
<li><a href="../api/proxy.md"><code>Observer.proxy()</code></a></li>
<li><a href="../api/unproxy.md"><code>Observer.unproxy()</code></a></li>
<li><a href="../api/closure.md"><code>Observer.closure()</code></a></li>
<li><a href="../api/init.md"><code>Observer.init()</code></a></li>
</ul>

		</div>

		<template name="set">
			<div exportgroup="readme">

				<h1 id="observerset"><code>Observer.set()</code></h1>
<p>This method is used to set the value of an object's property. It corresponds to the JavaScript's <code>Reflect.set()</code> function, which is itself the programmatic alternative to the assignment expression – <code>obj.property = value</code>.</p>
<p><code>Observer.set()</code> brings the added benefit of triggering <a href="../api/observe.md"><em>observers</em></a> and <a href="../api/intercept.md"><em>interceptors</em></a>.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#usage-as-a-traps-set-handler">Usage as a Trap's "set" Handler</a></li>
<li><a href="#usage-with-property-setters">Usage with Property Setters</a></li>
<li><a href="#Intercepting-observer.set">Intercepting <code>Observer.set()</code></a></li>
<li><a href="#related-methods">Related Methods</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Set or modify a specific property</span>
Observer.set(obj, propertyName, value[, params = {}]);

<span class="hljs-comment">// Set or modify a list of properties with the same value</span>
Observer.set(obj, propertyNames, value[, params = {}]);

<span class="hljs-comment">// Perform multiple key/value assignments</span>
Observer.set(obj, keyValueMap[, = {}]);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:             Object|Array</code> - an object or array.</li>
<li><code>propertyName:    String|Number</code> - the property to modify.</li>
<li><code>propertyNames:   Array</code> - a list of properties to modify.</li>
<li><code>value:           Any</code> - the value to set.</li>
<li><code>keyValueMap:     Object</code> - an object of key/value pairs.</li>
<li><code>params:          Object</code> - optional paramters for the operation.</li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>Boolean</em><br />
<em>Object</em> - See <a href="#returning-responses-back-from-observers">Returning Responses Back from Observers</a></p>
<h2 id="usage">Usage</h2>
<h3 id="assigning-on-a-specific-property">Assigning On a Specific Property</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an object</span>
Observer.set(obj, <span class="hljs-string">'fruit'</span>, <span class="hljs-string">'orange'</span>);
<span class="hljs-comment">// On an array</span>
Observer.set(arr, <span class="hljs-number">0</span>, <span class="hljs-string">'orange'</span>);</code></pre>
<h3 id="assigning-on-a-list-of-propertieskeys">Assigning On a List of Propertieskeys</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an object</span>
Observer.set(obj, [<span class="hljs-string">'fruit'</span>, <span class="hljs-string">'brand'</span>], <span class="hljs-string">'apple'</span>);
<span class="hljs-comment">// On an array</span>
Observer.set(arr, [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>], <span class="hljs-string">'apple'</span>);</code></pre>
<h3 id="multiple-keyvalue-assignment">Multiple Key/Value Assignment</h3>
<pre><code class="hljs js language-js"><span class="hljs-comment">// On an object</span>
Observer.set(obj, {
    <span class="hljs-attr">fruit</span>:<span class="hljs-string">'apple'</span>,
    <span class="hljs-attr">brand</span>:<span class="hljs-string">'apple'</span>
});

<span class="hljs-comment">// On an array</span>
<span class="hljs-comment">// Provide key/value as an object</span>
Observer.set(arr, {
    <span class="hljs-number">0</span>:<span class="hljs-string">'apple'</span>,
    <span class="hljs-number">3</span>:<span class="hljs-string">'apple'</span>
});</code></pre>
<h3 id="passing-a-value-to-observers">Passing a Value to Observers</h3>
<p>The <code>params.detail</code> property can be used to pass a value specifically to observers that might be responding to the <code>set</code> event. Any type of value can be passed.</p>
<pre><code class="hljs js language-js">Observer.set(obj, propertyName, value, {
    <span class="hljs-attr">detail</span>: <span class="hljs-string">'This is observer-specific detail'</span>,
});</code></pre>
<p>The <em>detail</em> above would now be available to every handler.</p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, event =&gt; {
    <span class="hljs-built_in">console</span>.log(event.detail);
});</code></pre>
<h3 id="returning-responses-back-from-observers">Returning Responses Back from Observers</h3>
<p>When a <em>set</em> operation fires an event, event handlers recieve a special object, called the <em>Response Object</em>, in addition to the standard event object. The Response Object can be used to, either <em>halt</em>, or <em>keep in sync</em> with what happens next.</p>
<p><strong>response.stopPropagation()</strong> cancels the event, that is, prevents the event from reaching other event handlers. Returning <code>false</code> from the handler has the same effect. </p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, (event, response) =&gt; {
    response.stopPropagation();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the <em>set</em> operation has to flag the event as <em>cancellable</em> for the above to be honoured. It may also obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = Observer.set(obj, propertyName, value, {
    <span class="hljs-attr">cancellable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">responseObject</span>: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.propagationStopped) {
}</code></pre>
<p><strong>response.preventDefault()</strong> tells the initiator of the <em>set</em> operation to skip the usual default action it takes after <em>set</em> operations. Returning <code>false</code> from the handler has the same effect. (The event still reaches other handlers.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, (event, response) =&gt; {
    response.preventDefault();
    <span class="hljs-comment">// Or, return false;</span>
});</code></pre>
<p>The initiator of the <em>set</em> operation may obtain the response object to determine the state of this response.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = Observer.set(obj, propertyName, value, {
    <span class="hljs-attr">responseObject</span>: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.defaultPrevented) {
}</code></pre>
<p><strong>response.waitUntil(promise)</strong> tells the initiator of the <em>set</em> operation to wait until a <em>Promise</em> is resolved before continuing with further operations. Returning a <code>Promise</code> from the handler has the same effect. (The event still reaches other handlers without waiting.)</p>
<pre><code class="hljs js language-js">Observer.observe(obj, propertyName, (event, response) =&gt; {
    <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        setTimeout(resolve, <span class="hljs-number">2000</span>);
    });
    response.waitUntil(promise);
    <span class="hljs-comment">// Or, return promise;</span>
});</code></pre>
<p>The initiator of the <em>set</em> operation may obtain the response object to determine the state of this response. The state of this response becomes a promise when one or more handlers return a promise.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> response = Observer.set(obj, propertyName, value, {
    <span class="hljs-attr">responseObject</span>: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">// Determine response state...</span>
<span class="hljs-keyword">if</span> (response.promises) {
    response.promises.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    });
}</code></pre>
<h2 id="usage-as-a-traps-set-handler">Usage as a Trap's "set" Handler</h2>
<p><code>Observer.set()</code> returns a <em>Boolean</em> value for <em>set</em> operations and can, therefore, be used as the "set" handler in Proxy traps.</p>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, {<span class="hljs-attr">set</span>: Observer.set});
<span class="hljs-keyword">let</span> _arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(arr, {<span class="hljs-attr">set</span>: Observer.set});</code></pre>
<p>Assignment operations will now be forwarded to <code>Observer.set()</code> and <a href="../api/observe.md"><em>observers</em></a> and <a href="../api/intercept.md"><em>interceptors</em></a> that may be bound to the object will continue to respond.</p>
<pre><code class="hljs js language-js">_obj.fruit = <span class="hljs-string">'apple'</span>;
_arr[<span class="hljs-number">2</span>] = <span class="hljs-string">'Item 3'</span>;</code></pre>
<h2 id="usage-with-property-setters">Usage with Property Setters</h2>
<p>It is possible to implement <em>property setters</em> that use <code>Observer.set()</code> behind the scene. This gives us the benefit of using JavaScript's assignment syntax while still driving <a href="../api/observe.md"><em>observers</em></a> and <a href="../api/intercept.md"><em>interceptors</em></a>.</p>
<p>This is automatically done by the <a href="../api/init.md"><code>Observer.init()</code></a> support function.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Virtualize a property or multiple properties</span>
Observer.init(obj, <span class="hljs-string">'fruit'</span>);
Observer.init(obj, [<span class="hljs-string">'fruit'</span>, <span class="hljs-string">'brand'</span>]);

<span class="hljs-comment">// Now we can do without Observer.set</span>
obj.fruit = <span class="hljs-string">'apple'</span>;
obj.brand = <span class="hljs-string">'apple'</span>;</code></pre>
<p>We could follow the pattern above for arrays; we could even <em>init</em> an array's prototype methods instead. The specific keys modified after calling these methods will be announced to <a href="../api/observe.md"><em>observers</em></a>.</p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Virtualize the arr.push() and arr.splice() methods</span>
Observer.init(arr, [<span class="hljs-string">'push'</span>, <span class="hljs-string">'splice'</span>]);

<span class="hljs-comment">// Now we can do without Observer.set</span>
arr.push(<span class="hljs-string">'Item 1'</span>);
arr.push(<span class="hljs-string">'Item 2'</span>);
arr.splice(<span class="hljs-number">1</span>);</code></pre>
<h2 id="intercepting-observerset">Intercepting <code>Observer.set()</code></h2>
<p>Using <a href="../api/intercept.md"><code>Observer.intercept()</code></a>, it is possible to intercept calls to <code>Observer.set()</code>. When a "set" operation triggers an interceptor, the interceptor will receive an event object containing the property name and the assignable value.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">'set'</span>, (event, recieved, next) =&gt; {
    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name, event.value);
    <span class="hljs-comment">// The assignment operation</span>
    obj[event.name] = event.value;
    <span class="hljs-comment">// The return value - Boolean</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
});

Observer.set(obj, <span class="hljs-string">'fruit'</span>, <span class="hljs-string">'orange'</span>);</code></pre>
<p>When the "set" operation is of multiple key/value assignments, the interceptor gets fired for each pair while also recieving the total list of properties as a hint - via <code>event.related</code>.</p>
<pre><code class="hljs js language-js">Observer.intercept(obj, <span class="hljs-string">'set'</span>, (event, recieved, next) =&gt; {
    <span class="hljs-comment">// What we recieved...</span>
    <span class="hljs-built_in">console</span>.log(event.name, event.value, event.related);
    <span class="hljs-comment">// The assignment operation</span>
    obj[event.name] = event.value;
    <span class="hljs-comment">// The return value - Boolean</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
});

Observer.set(obj, {<span class="hljs-attr">fruit</span>: <span class="hljs-string">'orange'</span>, <span class="hljs-attr">brand</span>:<span class="hljs-string">'apple'</span>});</code></pre>
<p>The above should trigger our interceptor twice with <code>event.related</code> being <code>['fruit', 'brand']</code>.</p>
<p>The interceptor is expected to return <em>true</em> when the operation is successful; <em>false</em> otherwise.</p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="../api/observe.md"><code>Observer.observe()</code></a></li>
<li><a href="../api/intercept.md"><code>Observer.intercept()</code></a></li>
</ul>

			</div>
		</template>

		<template name="unintercept">
			<div exportgroup="readme">

				<h1 id="observerunintercept"><code>Observer.unintercept()</code></h1>
<p>This method is used to unbind interceptors previously bound with <a href="/interceptor/api/intercept.md"><code>Observer.intercept()</code></a>.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#related-methods">Related Methods</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unbind all interceptors bound to the following property name</span>
<span class="hljs-comment">// regardless of the handler function</span>
Observer.unintercept(obj, type);

<span class="hljs-comment">// Unbind the interceptor bound with the following handler function</span>
Observer.unintercept(obj, type, originalHandler);

<span class="hljs-comment">// Unbind the interceptor bound with the following handler function and tags</span>
Observer.unintercept(obj, type, originalHandler, {<span class="hljs-attr">tags</span>:[...originalTags]});

<span class="hljs-comment">// Unbind all interceptors bound with the following tags</span>
<span class="hljs-comment">// regardless of the handler function</span>
Observer.unintercept(obj, type, <span class="hljs-literal">null</span>, {<span class="hljs-attr">tags</span>:[...originalTags]});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:             Object|Array</code> - an object or array.</li>
<li><code>type:            String</code> - if not <code>null</code>, the operation type used on <a href="/interceptor/api/intercept.md"><code>Observer.intercept()</code></a></li>
<li><code>originalHandler: Function</code> - if not <code>null</code>, the <em>original</em> callback function used on <a href="/interceptor/api/intercept.md"><code>Observer.intercept()</code></a></li>
<li><code>params.tags:     Array</code> - if not <code>null</code>, the list of <em>tags</em> (in any order) used on <a href="/interceptor/api/intercept.md"><code>Observer.intercept()</code></a></li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>undefined</em></p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="/interceptor/api/intercept.md"><code>Observer.intercept()</code></a></li>
</ul>

			</div>
		</template>

		<template name="unobserve">
			<div exportgroup="readme">

				<h1 id="observerunobserve"><code>Observer.unobserve()</code></h1>
<p>This method is used to unbind observers previously bound with <a href="../api/observe.md"><code>Observer.observe()</code></a>.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#related-methods">Related Methods</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unbind all observers bound to the following property name</span>
<span class="hljs-comment">// regardless of the handler function</span>
Observer.unobserve(obj, path);

<span class="hljs-comment">// Unbind the observer bound with the following handler function</span>
Observer.unobserve(obj, path, originalCallback);

<span class="hljs-comment">// Unbind the observer bound with the following handler function and tags</span>
Observer.unobserve(obj, path, originalCallback, {<span class="hljs-attr">tags</span>:[...originalTags]});

<span class="hljs-comment">// Unbind the observer bound with the following handler function and reflex type </span>
Observer.unobserve(obj, path, originalCallback, {<span class="hljs-attr">type</span>:’<span class="hljs-keyword">set</span>’});

// Unbind all observers bound with the following tags
// regardless of the handler function
Observer.unobserve(obj, paths, null, {tags:[...originalTags]});</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>obj:             Object|Array</code> - an object or array.</li>
<li><code>path:            String|Array</code> - if not <code>null</code>, a path to unobserve.</li>
<li><code>paths:           Array</code> - if not <code>null</code>, the list of paths (in any order) to unobserve.</li>
<li><code>originalCallback: Function</code> - if not <code>null</code>, the <em>original</em> callback function used during <a href="../api/observe.md"><code>observe()</code></a></li>
<li><code>params.tags:     Array</code> - if not <code>null</code>, the list of the <em>original</em> tags (in any order) used during <a href="../api/observe.md"><code>observe()</code></a></li>
</ul>
<p><strong>Return Value</strong></p>
<p><em>undefined</em></p>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="../api/observe.md"><code>Observer.observe()</code></a></li>
</ul>

			</div>
		</template>

		<template name="unproxy">
			<div exportgroup="readme">

				<h1 id="observerproxy"><code>Observer.proxy()</code></h1>
<p>This function is used to obtain the original object or array previously wrapped in a proxy using <a href="../api/proxy.md"><code>Observer.proxy()</code></a>.</p>
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#related-methods">Related Methods</a></li>
</ul>
<h2 id="syntax">Syntax</h2>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Unwrap an object</span>
<span class="hljs-keyword">let</span> obj = Observer.unproxy(_obj);</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li><code>_obj: Proxy</code> - a Proxy object generated by <a href="../api/proxy.md"><code>Observer.proxy()</code></a>.</li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li><code>obj: Object|Array</code></li>
</ul>
<h2 id="usage">Usage</h2>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {};
<span class="hljs-comment">// The proxy</span>
<span class="hljs-keyword">let</span> _obj = Observer.proxy(obj);

<span class="hljs-comment">// The original object</span>
<span class="hljs-keyword">let</span> obj = Observer.unproxy(_obj);</code></pre>
<h2 id="related-methods">Related Methods</h2>
<ul>
<li><a href="../api/proxy.md"><code>Observer.proxy()</code></a></li>
</ul>

			</div>
		</template>
	</template>

	

	<template name="examples">
		<div exportgroup="readme">

			<h1 id="examples">Examples</h1>
<p>The following are a few direct links to examples in the API docs.</p>
<ul>
<li><a href="../api/observe.md#usage"><code>Observer.observe()</code></a></li>
<li><a href="../api/intercept.md#usage"><code>Observer.intercept()</code></a></li>
</ul>

		</div>
	</template>

	<template name="installation">
		<div exportgroup="readme">

			<h1 id="installation">Installation</h1>
<p>Observer is usable in both browser and server environments.</p>
<h2 id="embed-as-script">Embed as script</h2>
<pre><code class="hljs html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/@webqit/observer/dist/main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
<span class="hljs-comment">// The above tag loads Observer into a global "WQ" object.</span>
<span class="hljs-keyword">const</span> Observer = WQ.Observer;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="install-via-npm">Install via npm</h2>
<pre><code class="hljs text language-text">$ <span class="hljs-built_in">npm</span> i -g <span class="hljs-built_in">npm</span>
$ <span class="hljs-built_in">npm</span> i --save @webqit/observer</code></pre>
<p><strong>Import with the <code>import</code> keyword:</strong></p>
<pre><code class="hljs js language-js"><span class="hljs-comment">// Node-style import</span>
<span class="hljs-keyword">import</span> Observer <span class="hljs-keyword">from</span> <span class="hljs-string">'@webqit/observer'</span>;

<span class="hljs-comment">// Standard JavaScript import. (Actual path depends on where you installed Observer to.)</span>
<span class="hljs-keyword">import</span> Observer <span class="hljs-keyword">from</span> <span class="hljs-string">'./node_modules/@webqit/observer/src/index.js'</span>;</code></pre>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {};
Observer.observe(obj, changes =&gt; {
    <span class="hljs-built_in">console</span>.log(changes.map(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> event.type + <span class="hljs-string">': '</span> + event.name));
});

Observer.set(obj, <span class="hljs-string">'property'</span>, value);</code></pre>
<h2 id="documentation">Documentation</h2>
<ul>
<li><a href="../examples/README.md">Examples</a></li>
<li><a href="../api/README.md">API Docs</a></li>
</ul>

		</div>
	</template>

	<div exportgroup="readme">

		<h1 id="the-observer-api">The Observer API</h1>
<!-- BADGES/ -->
<p><span class="badge-npmversion"><a href="https://npmjs.org/package/@webqit/observer" title="View this project on NPM"><img src="https://img.shields.io/npm/v/@webqit/observer.svg" alt="NPM version" /></a></span><br />
<span class="badge-npmdownloads"><a href="https://npmjs.org/package/@webqit/observer" title="View this project on NPM"><img src="https://img.shields.io/npm/dm/@webqit/observer.svg" alt="NPM downloads" /></a></span></p>
<!-- /BADGES -->
<p><em><a href="https://webqit.io/tooling/observer">Observer</a></em> is an API for intercepting and observing JavaScript objects and arrays.</p>
<blockquote>
  <p><a href="https://github.com/webqit/observer">Visit this project on GitHub</a>.</p>
</blockquote>
<pre><code class="hljs js language-js"><span class="hljs-keyword">let</span> obj = {};
Observer.observe(obj, events =&gt; {
    events.forEach(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(event.type, event.name, event.path, event.value, event.oldValue);
    });
});

Observer.set(obj, path, value);</code></pre>
<p>Follow the <a href="installation/README.md">installation guide</a> to obtain the Observer API.</p>
<h2 id="documentation">Documentation</h2>
<ul>
<li><a href="examples/README.md">Examples</a></li>
<li><a href="api/README.md">API</a></li>
</ul>
<h2 id="issues">Issues</h2>
<p>To report bugs or request features, please submit an <a href="https://github.com/webqit/observer/issues">issue</a>.</p>
<h2 id="license">License</h2>
<p>MIT.</p>

	</div>
